// 
// Copyright 2022 Amazon.com, Inc. or its affiliates. All Rights Reserved.
// 
// Licensed under the Apache License, Version 2.0 (the "License").
// You may not use this file except in compliance with the License.
// A copy of the License is located at
// 
//  http://aws.amazon.com/apache2.0
// 
// or in the "license" file accompanying this file. This file is distributed
// on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
// express or implied. See the License for the specific language governing
// permissions and limitations under the License.
//  
// Autogenerated from Pigeon (v3.2.7), do not edit directly.
// See also: https://pub.dev/packages/pigeon
#import "NativeAuthPlugin.h"
#import <Flutter/Flutter.h>

#if !__has_feature(objc_arc)
#error File requires ARC to be enabled.
#endif

static NSDictionary<NSString *, id> *wrapResult(id result, FlutterError *error) {
  NSDictionary *errorDict = (NSDictionary *)[NSNull null];
  if (error) {
    errorDict = @{
        @"code": (error.code ?: [NSNull null]),
        @"message": (error.message ?: [NSNull null]),
        @"details": (error.details ?: [NSNull null]),
        };
  }
  return @{
      @"result": (result ?: [NSNull null]),
      @"error": errorDict,
      };
}
static id GetNullableObject(NSDictionary* dict, id key) {
  id result = dict[key];
  return (result == [NSNull null]) ? nil : result;
}
static id GetNullableObjectAtIndex(NSArray* array, NSInteger key) {
  id result = array[key];
  return (result == [NSNull null]) ? nil : result;
}


@interface NativeAuthSession ()
+ (NativeAuthSession *)fromMap:(NSDictionary *)dict;
+ (nullable NativeAuthSession *)nullableFromMap:(NSDictionary *)dict;
- (NSDictionary *)toMap;
@end
@interface NativeAuthUser ()
+ (NativeAuthUser *)fromMap:(NSDictionary *)dict;
+ (nullable NativeAuthUser *)nullableFromMap:(NSDictionary *)dict;
- (NSDictionary *)toMap;
@end
@interface NativeUserPoolTokens ()
+ (NativeUserPoolTokens *)fromMap:(NSDictionary *)dict;
+ (nullable NativeUserPoolTokens *)nullableFromMap:(NSDictionary *)dict;
- (NSDictionary *)toMap;
@end
@interface NativeAWSCredentials ()
+ (NativeAWSCredentials *)fromMap:(NSDictionary *)dict;
+ (nullable NativeAWSCredentials *)nullableFromMap:(NSDictionary *)dict;
- (NSDictionary *)toMap;
@end
@interface LegacyCredentialStoreData ()
+ (LegacyCredentialStoreData *)fromMap:(NSDictionary *)dict;
+ (nullable LegacyCredentialStoreData *)nullableFromMap:(NSDictionary *)dict;
- (NSDictionary *)toMap;
@end

@implementation NativeAuthSession
+ (instancetype)makeWithIsSignedIn:(NSNumber *)isSignedIn
    userSub:(nullable NSString *)userSub
    userPoolTokens:(nullable NativeUserPoolTokens *)userPoolTokens
    identityId:(nullable NSString *)identityId
    awsCredentials:(nullable NativeAWSCredentials *)awsCredentials {
  NativeAuthSession* pigeonResult = [[NativeAuthSession alloc] init];
  pigeonResult.isSignedIn = isSignedIn;
  pigeonResult.userSub = userSub;
  pigeonResult.userPoolTokens = userPoolTokens;
  pigeonResult.identityId = identityId;
  pigeonResult.awsCredentials = awsCredentials;
  return pigeonResult;
}
+ (NativeAuthSession *)fromMap:(NSDictionary *)dict {
  NativeAuthSession *pigeonResult = [[NativeAuthSession alloc] init];
  pigeonResult.isSignedIn = GetNullableObject(dict, @"isSignedIn");
  NSAssert(pigeonResult.isSignedIn != nil, @"");
  pigeonResult.userSub = GetNullableObject(dict, @"userSub");
  pigeonResult.userPoolTokens = [NativeUserPoolTokens nullableFromMap:GetNullableObject(dict, @"userPoolTokens")];
  pigeonResult.identityId = GetNullableObject(dict, @"identityId");
  pigeonResult.awsCredentials = [NativeAWSCredentials nullableFromMap:GetNullableObject(dict, @"awsCredentials")];
  return pigeonResult;
}
+ (nullable NativeAuthSession *)nullableFromMap:(NSDictionary *)dict { return (dict) ? [NativeAuthSession fromMap:dict] : nil; }
- (NSDictionary *)toMap {
  return @{
    @"isSignedIn" : (self.isSignedIn ?: [NSNull null]),
    @"userSub" : (self.userSub ?: [NSNull null]),
    @"userPoolTokens" : (self.userPoolTokens ? [self.userPoolTokens toMap] : [NSNull null]),
    @"identityId" : (self.identityId ?: [NSNull null]),
    @"awsCredentials" : (self.awsCredentials ? [self.awsCredentials toMap] : [NSNull null]),
  };
}
@end

@implementation NativeAuthUser
+ (instancetype)makeWithUserId:(NSString *)userId
    username:(NSString *)username {
  NativeAuthUser* pigeonResult = [[NativeAuthUser alloc] init];
  pigeonResult.userId = userId;
  pigeonResult.username = username;
  return pigeonResult;
}
+ (NativeAuthUser *)fromMap:(NSDictionary *)dict {
  NativeAuthUser *pigeonResult = [[NativeAuthUser alloc] init];
  pigeonResult.userId = GetNullableObject(dict, @"userId");
  NSAssert(pigeonResult.userId != nil, @"");
  pigeonResult.username = GetNullableObject(dict, @"username");
  NSAssert(pigeonResult.username != nil, @"");
  return pigeonResult;
}
+ (nullable NativeAuthUser *)nullableFromMap:(NSDictionary *)dict { return (dict) ? [NativeAuthUser fromMap:dict] : nil; }
- (NSDictionary *)toMap {
  return @{
    @"userId" : (self.userId ?: [NSNull null]),
    @"username" : (self.username ?: [NSNull null]),
  };
}
@end

@implementation NativeUserPoolTokens
+ (instancetype)makeWithAccessToken:(NSString *)accessToken
    refreshToken:(NSString *)refreshToken
    idToken:(NSString *)idToken {
  NativeUserPoolTokens* pigeonResult = [[NativeUserPoolTokens alloc] init];
  pigeonResult.accessToken = accessToken;
  pigeonResult.refreshToken = refreshToken;
  pigeonResult.idToken = idToken;
  return pigeonResult;
}
+ (NativeUserPoolTokens *)fromMap:(NSDictionary *)dict {
  NativeUserPoolTokens *pigeonResult = [[NativeUserPoolTokens alloc] init];
  pigeonResult.accessToken = GetNullableObject(dict, @"accessToken");
  NSAssert(pigeonResult.accessToken != nil, @"");
  pigeonResult.refreshToken = GetNullableObject(dict, @"refreshToken");
  NSAssert(pigeonResult.refreshToken != nil, @"");
  pigeonResult.idToken = GetNullableObject(dict, @"idToken");
  NSAssert(pigeonResult.idToken != nil, @"");
  return pigeonResult;
}
+ (nullable NativeUserPoolTokens *)nullableFromMap:(NSDictionary *)dict { return (dict) ? [NativeUserPoolTokens fromMap:dict] : nil; }
- (NSDictionary *)toMap {
  return @{
    @"accessToken" : (self.accessToken ?: [NSNull null]),
    @"refreshToken" : (self.refreshToken ?: [NSNull null]),
    @"idToken" : (self.idToken ?: [NSNull null]),
  };
}
@end

@implementation NativeAWSCredentials
+ (instancetype)makeWithAccessKeyId:(NSString *)accessKeyId
    secretAccessKey:(NSString *)secretAccessKey
    sessionToken:(nullable NSString *)sessionToken
    expirationIso8601Utc:(nullable NSString *)expirationIso8601Utc {
  NativeAWSCredentials* pigeonResult = [[NativeAWSCredentials alloc] init];
  pigeonResult.accessKeyId = accessKeyId;
  pigeonResult.secretAccessKey = secretAccessKey;
  pigeonResult.sessionToken = sessionToken;
  pigeonResult.expirationIso8601Utc = expirationIso8601Utc;
  return pigeonResult;
}
+ (NativeAWSCredentials *)fromMap:(NSDictionary *)dict {
  NativeAWSCredentials *pigeonResult = [[NativeAWSCredentials alloc] init];
  pigeonResult.accessKeyId = GetNullableObject(dict, @"accessKeyId");
  NSAssert(pigeonResult.accessKeyId != nil, @"");
  pigeonResult.secretAccessKey = GetNullableObject(dict, @"secretAccessKey");
  NSAssert(pigeonResult.secretAccessKey != nil, @"");
  pigeonResult.sessionToken = GetNullableObject(dict, @"sessionToken");
  pigeonResult.expirationIso8601Utc = GetNullableObject(dict, @"expirationIso8601Utc");
  return pigeonResult;
}
+ (nullable NativeAWSCredentials *)nullableFromMap:(NSDictionary *)dict { return (dict) ? [NativeAWSCredentials fromMap:dict] : nil; }
- (NSDictionary *)toMap {
  return @{
    @"accessKeyId" : (self.accessKeyId ?: [NSNull null]),
    @"secretAccessKey" : (self.secretAccessKey ?: [NSNull null]),
    @"sessionToken" : (self.sessionToken ?: [NSNull null]),
    @"expirationIso8601Utc" : (self.expirationIso8601Utc ?: [NSNull null]),
  };
}
@end

@implementation LegacyCredentialStoreData
+ (instancetype)makeWithIdentityId:(nullable NSString *)identityId
    accessKeyId:(nullable NSString *)accessKeyId
    secretAccessKey:(nullable NSString *)secretAccessKey
    sessionToken:(nullable NSString *)sessionToken
    expirationMsSinceEpoch:(nullable NSNumber *)expirationMsSinceEpoch
    accessToken:(nullable NSString *)accessToken
    refreshToken:(nullable NSString *)refreshToken
    idToken:(nullable NSString *)idToken {
  LegacyCredentialStoreData* pigeonResult = [[LegacyCredentialStoreData alloc] init];
  pigeonResult.identityId = identityId;
  pigeonResult.accessKeyId = accessKeyId;
  pigeonResult.secretAccessKey = secretAccessKey;
  pigeonResult.sessionToken = sessionToken;
  pigeonResult.expirationMsSinceEpoch = expirationMsSinceEpoch;
  pigeonResult.accessToken = accessToken;
  pigeonResult.refreshToken = refreshToken;
  pigeonResult.idToken = idToken;
  return pigeonResult;
}
+ (LegacyCredentialStoreData *)fromMap:(NSDictionary *)dict {
  LegacyCredentialStoreData *pigeonResult = [[LegacyCredentialStoreData alloc] init];
  pigeonResult.identityId = GetNullableObject(dict, @"identityId");
  pigeonResult.accessKeyId = GetNullableObject(dict, @"accessKeyId");
  pigeonResult.secretAccessKey = GetNullableObject(dict, @"secretAccessKey");
  pigeonResult.sessionToken = GetNullableObject(dict, @"sessionToken");
  pigeonResult.expirationMsSinceEpoch = GetNullableObject(dict, @"expirationMsSinceEpoch");
  pigeonResult.accessToken = GetNullableObject(dict, @"accessToken");
  pigeonResult.refreshToken = GetNullableObject(dict, @"refreshToken");
  pigeonResult.idToken = GetNullableObject(dict, @"idToken");
  return pigeonResult;
}
+ (nullable LegacyCredentialStoreData *)nullableFromMap:(NSDictionary *)dict { return (dict) ? [LegacyCredentialStoreData fromMap:dict] : nil; }
- (NSDictionary *)toMap {
  return @{
    @"identityId" : (self.identityId ?: [NSNull null]),
    @"accessKeyId" : (self.accessKeyId ?: [NSNull null]),
    @"secretAccessKey" : (self.secretAccessKey ?: [NSNull null]),
    @"sessionToken" : (self.sessionToken ?: [NSNull null]),
    @"expirationMsSinceEpoch" : (self.expirationMsSinceEpoch ?: [NSNull null]),
    @"accessToken" : (self.accessToken ?: [NSNull null]),
    @"refreshToken" : (self.refreshToken ?: [NSNull null]),
    @"idToken" : (self.idToken ?: [NSNull null]),
  };
}
@end

@interface NativeAuthPluginCodecReader : FlutterStandardReader
@end
@implementation NativeAuthPluginCodecReader
- (nullable id)readValueOfType:(UInt8)type 
{
  switch (type) {
    case 128:     
      return [NativeAWSCredentials fromMap:[self readValue]];
    
    case 129:     
      return [NativeAuthSession fromMap:[self readValue]];
    
    case 130:     
      return [NativeUserPoolTokens fromMap:[self readValue]];
    
    default:    
      return [super readValueOfType:type];
    
  }
}
@end

@interface NativeAuthPluginCodecWriter : FlutterStandardWriter
@end
@implementation NativeAuthPluginCodecWriter
- (void)writeValue:(id)value 
{
  if ([value isKindOfClass:[NativeAWSCredentials class]]) {
    [self writeByte:128];
    [self writeValue:[value toMap]];
  } else 
  if ([value isKindOfClass:[NativeAuthSession class]]) {
    [self writeByte:129];
    [self writeValue:[value toMap]];
  } else 
  if ([value isKindOfClass:[NativeUserPoolTokens class]]) {
    [self writeByte:130];
    [self writeValue:[value toMap]];
  } else 
{
    [super writeValue:value];
  }
}
@end

@interface NativeAuthPluginCodecReaderWriter : FlutterStandardReaderWriter
@end
@implementation NativeAuthPluginCodecReaderWriter
- (FlutterStandardWriter *)writerWithData:(NSMutableData *)data {
  return [[NativeAuthPluginCodecWriter alloc] initWithData:data];
}
- (FlutterStandardReader *)readerWithData:(NSData *)data {
  return [[NativeAuthPluginCodecReader alloc] initWithData:data];
}
@end

NSObject<FlutterMessageCodec> *NativeAuthPluginGetCodec() {
  static dispatch_once_t sPred = 0;
  static FlutterStandardMessageCodec *sSharedObject = nil;
  dispatch_once(&sPred, ^{
    NativeAuthPluginCodecReaderWriter *readerWriter = [[NativeAuthPluginCodecReaderWriter alloc] init];
    sSharedObject = [FlutterStandardMessageCodec codecWithReaderWriter:readerWriter];
  });
  return sSharedObject;
}


@interface NativeAuthPlugin ()
@property (nonatomic, strong) NSObject<FlutterBinaryMessenger> *binaryMessenger;
@end

@implementation NativeAuthPlugin

- (instancetype)initWithBinaryMessenger:(NSObject<FlutterBinaryMessenger> *)binaryMessenger {
  self = [super init];
  if (self) {
    _binaryMessenger = binaryMessenger;
  }
  return self;
}
- (void)exchangeParams:(NSDictionary<NSString *, NSString *> *)arg_params completion:(void(^)(NSError *_Nullable))completion {
  FlutterBasicMessageChannel *channel =
    [FlutterBasicMessageChannel
      messageChannelWithName:@"dev.flutter.pigeon.NativeAuthPlugin.exchange"
      binaryMessenger:self.binaryMessenger
      codec:NativeAuthPluginGetCodec()];
  [channel sendMessage:@[arg_params ?: [NSNull null]] reply:^(id reply) {
    completion(nil);
  }];
}
- (void)fetchAuthSessionGetAwsCredentials:(NSNumber *)arg_getAwsCredentials completion:(void(^)(NativeAuthSession *_Nullable, NSError *_Nullable))completion {
  FlutterBasicMessageChannel *channel =
    [FlutterBasicMessageChannel
      messageChannelWithName:@"dev.flutter.pigeon.NativeAuthPlugin.fetchAuthSession"
      binaryMessenger:self.binaryMessenger
      codec:NativeAuthPluginGetCodec()];
  [channel sendMessage:@[arg_getAwsCredentials ?: [NSNull null]] reply:^(id reply) {
    NativeAuthSession *output = reply;
    completion(output, nil);
  }];
}
@end
@interface NativeAuthBridgeCodecReader : FlutterStandardReader
@end
@implementation NativeAuthBridgeCodecReader
- (nullable id)readValueOfType:(UInt8)type 
{
  switch (type) {
    case 128:     
      return [LegacyCredentialStoreData fromMap:[self readValue]];
    
    case 129:     
      return [NativeAuthUser fromMap:[self readValue]];
    
    default:    
      return [super readValueOfType:type];
    
  }
}
@end

@interface NativeAuthBridgeCodecWriter : FlutterStandardWriter
@end
@implementation NativeAuthBridgeCodecWriter
- (void)writeValue:(id)value 
{
  if ([value isKindOfClass:[LegacyCredentialStoreData class]]) {
    [self writeByte:128];
    [self writeValue:[value toMap]];
  } else 
  if ([value isKindOfClass:[NativeAuthUser class]]) {
    [self writeByte:129];
    [self writeValue:[value toMap]];
  } else 
{
    [super writeValue:value];
  }
}
@end

@interface NativeAuthBridgeCodecReaderWriter : FlutterStandardReaderWriter
@end
@implementation NativeAuthBridgeCodecReaderWriter
- (FlutterStandardWriter *)writerWithData:(NSMutableData *)data {
  return [[NativeAuthBridgeCodecWriter alloc] initWithData:data];
}
- (FlutterStandardReader *)readerWithData:(NSData *)data {
  return [[NativeAuthBridgeCodecReader alloc] initWithData:data];
}
@end

NSObject<FlutterMessageCodec> *NativeAuthBridgeGetCodec() {
  static dispatch_once_t sPred = 0;
  static FlutterStandardMessageCodec *sSharedObject = nil;
  dispatch_once(&sPred, ^{
    NativeAuthBridgeCodecReaderWriter *readerWriter = [[NativeAuthBridgeCodecReaderWriter alloc] init];
    sSharedObject = [FlutterStandardMessageCodec codecWithReaderWriter:readerWriter];
  });
  return sSharedObject;
}


void NativeAuthBridgeSetup(id<FlutterBinaryMessenger> binaryMessenger, NSObject<NativeAuthBridge> *api) {
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.NativeAuthBridge.addPlugin"
        binaryMessenger:binaryMessenger
        codec:NativeAuthBridgeGetCodec()        ];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(addPluginWithCompletion:)], @"NativeAuthBridge api (%@) doesn't respond to @selector(addPluginWithCompletion:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        [api addPluginWithCompletion:^(FlutterError *_Nullable error) {
          callback(wrapResult(nil, error));
        }];
      }];
    }
    else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.NativeAuthBridge.signInWithUrl"
        binaryMessenger:binaryMessenger
        codec:NativeAuthBridgeGetCodec()        ];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(signInWithUrlUrl:callbackUrlScheme:preferPrivateSession:browserPackageName:completion:)], @"NativeAuthBridge api (%@) doesn't respond to @selector(signInWithUrlUrl:callbackUrlScheme:preferPrivateSession:browserPackageName:completion:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        NSString *arg_url = GetNullableObjectAtIndex(args, 0);
        NSString *arg_callbackUrlScheme = GetNullableObjectAtIndex(args, 1);
        NSNumber *arg_preferPrivateSession = GetNullableObjectAtIndex(args, 2);
        NSString *arg_browserPackageName = GetNullableObjectAtIndex(args, 3);
        [api signInWithUrlUrl:arg_url callbackUrlScheme:arg_callbackUrlScheme preferPrivateSession:arg_preferPrivateSession browserPackageName:arg_browserPackageName completion:^(NSDictionary<NSString *, NSString *> *_Nullable output, FlutterError *_Nullable error) {
          callback(wrapResult(output, error));
        }];
      }];
    }
    else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.NativeAuthBridge.signOutWithUrl"
        binaryMessenger:binaryMessenger
        codec:NativeAuthBridgeGetCodec()        ];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(signOutWithUrlUrl:callbackUrlScheme:preferPrivateSession:browserPackageName:completion:)], @"NativeAuthBridge api (%@) doesn't respond to @selector(signOutWithUrlUrl:callbackUrlScheme:preferPrivateSession:browserPackageName:completion:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        NSString *arg_url = GetNullableObjectAtIndex(args, 0);
        NSString *arg_callbackUrlScheme = GetNullableObjectAtIndex(args, 1);
        NSNumber *arg_preferPrivateSession = GetNullableObjectAtIndex(args, 2);
        NSString *arg_browserPackageName = GetNullableObjectAtIndex(args, 3);
        [api signOutWithUrlUrl:arg_url callbackUrlScheme:arg_callbackUrlScheme preferPrivateSession:arg_preferPrivateSession browserPackageName:arg_browserPackageName completion:^(FlutterError *_Nullable error) {
          callback(wrapResult(nil, error));
        }];
      }];
    }
    else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.NativeAuthBridge.getValidationData"
        binaryMessenger:binaryMessenger
        codec:NativeAuthBridgeGetCodec()        ];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(getValidationDataWithError:)], @"NativeAuthBridge api (%@) doesn't respond to @selector(getValidationDataWithError:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        FlutterError *error;
        NSDictionary<NSString *, NSString *> *output = [api getValidationDataWithError:&error];
        callback(wrapResult(output, error));
      }];
    }
    else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.NativeAuthBridge.getBundleId"
        binaryMessenger:binaryMessenger
        codec:NativeAuthBridgeGetCodec()        ];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(getBundleIdWithError:)], @"NativeAuthBridge api (%@) doesn't respond to @selector(getBundleIdWithError:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        FlutterError *error;
        NSString *output = [api getBundleIdWithError:&error];
        callback(wrapResult(output, error));
      }];
    }
    else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.NativeAuthBridge.updateCurrentUser"
        binaryMessenger:binaryMessenger
        codec:NativeAuthBridgeGetCodec()        ];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(updateCurrentUserUser:error:)], @"NativeAuthBridge api (%@) doesn't respond to @selector(updateCurrentUserUser:error:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        NativeAuthUser *arg_user = GetNullableObjectAtIndex(args, 0);
        FlutterError *error;
        [api updateCurrentUserUser:arg_user error:&error];
        callback(wrapResult(nil, error));
      }];
    }
    else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.NativeAuthBridge.getLegacyCredentials"
        binaryMessenger:binaryMessenger
        codec:NativeAuthBridgeGetCodec()        ];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(getLegacyCredentialsIdentityPoolId:appClientId:completion:)], @"NativeAuthBridge api (%@) doesn't respond to @selector(getLegacyCredentialsIdentityPoolId:appClientId:completion:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        NSString *arg_identityPoolId = GetNullableObjectAtIndex(args, 0);
        NSString *arg_appClientId = GetNullableObjectAtIndex(args, 1);
        [api getLegacyCredentialsIdentityPoolId:arg_identityPoolId appClientId:arg_appClientId completion:^(LegacyCredentialStoreData *_Nullable output, FlutterError *_Nullable error) {
          callback(wrapResult(output, error));
        }];
      }];
    }
    else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.NativeAuthBridge.clearLegacyCredentials"
        binaryMessenger:binaryMessenger
        codec:NativeAuthBridgeGetCodec()        ];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(clearLegacyCredentialsWithCompletion:)], @"NativeAuthBridge api (%@) doesn't respond to @selector(clearLegacyCredentialsWithCompletion:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        [api clearLegacyCredentialsWithCompletion:^(FlutterError *_Nullable error) {
          callback(wrapResult(nil, error));
        }];
      }];
    }
    else {
      [channel setMessageHandler:nil];
    }
  }
}
