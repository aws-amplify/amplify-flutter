// Generated with smithy-dart 0.3.1. DO NOT MODIFY.
// ignore_for_file: avoid_unused_constructor_parameters,deprecated_member_use_from_same_package,non_constant_identifier_names

library smoke_test.api_gateway.model.model; // ignore_for_file: no_leading_underscores_for_library_prefixes

import 'package:aws_common/aws_common.dart' as _i1;
import 'package:built_value/built_value.dart';
import 'package:built_value/serializer.dart';
import 'package:smithy/smithy.dart' as _i2;

part 'model.g.dart';

/// Represents the data structure of a method's request or response payload.
abstract class Model
    with _i1.AWSEquatable<Model>
    implements Built<Model, ModelBuilder> {
  /// Represents the data structure of a method's request or response payload.
  factory Model({
    String? id,
    String? name,
    String? description,
    String? schema,
    String? contentType,
  }) {
    return _$Model._(
      id: id,
      name: name,
      description: description,
      schema: schema,
      contentType: contentType,
    );
  }

  /// Represents the data structure of a method's request or response payload.
  factory Model.build([void Function(ModelBuilder) updates]) = _$Model;

  const Model._();

  /// Constructs a [Model] from a [payload] and [response].
  factory Model.fromResponse(
    Model payload,
    _i1.AWSBaseHttpResponse response,
  ) =>
      payload;

  static const List<_i2.SmithySerializer<Model>> serializers = [
    ModelRestJson1Serializer()
  ];

  @BuiltValueHook(initializeBuilder: true)
  static void _init(ModelBuilder b) {}

  /// The identifier for the model resource.
  String? get id;

  /// The name of the model. Must be an alphanumeric string.
  String? get name;

  /// The description of the model.
  String? get description;

  /// The schema for the model. For `application/json` models, this should be JSON schema draft 4 model. Do not include "\*/" characters in the description of any properties because such "\*/" characters may be interpreted as the closing marker for comments in some languages, such as Java or JavaScript, causing the installation of your API's SDK generated by API Gateway to fail.
  String? get schema;

  /// The content-type for the model.
  String? get contentType;
  @override
  List<Object?> get props => [
        id,
        name,
        description,
        schema,
        contentType,
      ];
  @override
  String toString() {
    final helper = newBuiltValueToStringHelper('Model')
      ..add(
        'id',
        id,
      )
      ..add(
        'name',
        name,
      )
      ..add(
        'description',
        description,
      )
      ..add(
        'schema',
        schema,
      )
      ..add(
        'contentType',
        contentType,
      );
    return helper.toString();
  }
}

class ModelRestJson1Serializer extends _i2.StructuredSmithySerializer<Model> {
  const ModelRestJson1Serializer() : super('Model');

  @override
  Iterable<Type> get types => const [
        Model,
        _$Model,
      ];
  @override
  Iterable<_i2.ShapeId> get supportedProtocols => const [
        _i2.ShapeId(
          namespace: 'aws.protocols',
          shape: 'restJson1',
        )
      ];
  @override
  Model deserialize(
    Serializers serializers,
    Iterable<Object?> serialized, {
    FullType specifiedType = FullType.unspecified,
  }) {
    final result = ModelBuilder();
    final iterator = serialized.iterator;
    while (iterator.moveNext()) {
      final key = iterator.current as String;
      iterator.moveNext();
      final value = iterator.current;
      if (value == null) {
        continue;
      }
      switch (key) {
        case 'contentType':
          result.contentType = (serializers.deserialize(
            value,
            specifiedType: const FullType(String),
          ) as String);
        case 'description':
          result.description = (serializers.deserialize(
            value,
            specifiedType: const FullType(String),
          ) as String);
        case 'id':
          result.id = (serializers.deserialize(
            value,
            specifiedType: const FullType(String),
          ) as String);
        case 'name':
          result.name = (serializers.deserialize(
            value,
            specifiedType: const FullType(String),
          ) as String);
        case 'schema':
          result.schema = (serializers.deserialize(
            value,
            specifiedType: const FullType(String),
          ) as String);
      }
    }

    return result.build();
  }

  @override
  Iterable<Object?> serialize(
    Serializers serializers,
    Model object, {
    FullType specifiedType = FullType.unspecified,
  }) {
    final result$ = <Object?>[];
    final Model(:contentType, :description, :id, :name, :schema) = object;
    if (contentType != null) {
      result$
        ..add('contentType')
        ..add(serializers.serialize(
          contentType,
          specifiedType: const FullType(String),
        ));
    }
    if (description != null) {
      result$
        ..add('description')
        ..add(serializers.serialize(
          description,
          specifiedType: const FullType(String),
        ));
    }
    if (id != null) {
      result$
        ..add('id')
        ..add(serializers.serialize(
          id,
          specifiedType: const FullType(String),
        ));
    }
    if (name != null) {
      result$
        ..add('name')
        ..add(serializers.serialize(
          name,
          specifiedType: const FullType(String),
        ));
    }
    if (schema != null) {
      result$
        ..add('schema')
        ..add(serializers.serialize(
          schema,
          specifiedType: const FullType(String),
        ));
    }
    return result$;
  }
}
