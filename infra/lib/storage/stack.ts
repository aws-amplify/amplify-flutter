/**
 * Copyright 2022 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import * as cdk from "aws-cdk-lib";
import { RemovalPolicy } from "aws-cdk-lib";
import * as cognito from "aws-cdk-lib/aws-cognito";
import * as iam from "aws-cdk-lib/aws-iam";
import * as lambda from "aws-cdk-lib/aws-lambda";
import * as lambda_nodejs from "aws-cdk-lib/aws-lambda-nodejs";
import * as s3 from "aws-cdk-lib/aws-s3";
import { Construct } from "constructs";
import {
  AmplifyCategory, IntegrationTestStack,
  IntegrationTestStackEnvironment,
  IntegrationTestStackEnvironmentProps
} from "../common";

export enum StorageAccessLevel {
  public = "guest",
  protected = "protected",
  private = "private",
}

enum StoragePermission {
  get = "s3:GetObject",
  put = "s3:PutObject",
  delete = "s3:DeleteObject",
}

interface StorageIntegrationTestEnvironmentProps extends IntegrationTestStackEnvironmentProps {
  /**
   * The default access level for the environment.
   */
  defaultAccessLevel?: StorageAccessLevel;

  /**
   * The access levels and accompanying permissions.
   */
  accessLevels?: Record<StorageAccessLevel, StoragePermission[]>;

  /**
   * Resolves the bucket key prefix for a given `accessLevel` and `identityId`.
   */
  prefixResolver?: (
    accessLevel: StorageAccessLevel,
    identityId: string
  ) => string;

  prefixOverrides?: Record<StorageAccessLevel, String>;
}

export class StorageIntegrationTestStack extends IntegrationTestStack<
  StorageIntegrationTestEnvironmentProps,
  StorageIntgrationTestEnvironment
> {
  constructor(
    scope: Construct,
    environments: StorageIntegrationTestEnvironmentProps[],
    props?: cdk.NestedStackProps,
  ) {
    super(scope, "StorageIntegTestStack", environments, props);
  }

  category: AmplifyCategory = AmplifyCategory.Storage;

  protected buildEnvironments(
    environments: StorageIntegrationTestEnvironmentProps[]
  ): StorageIntgrationTestEnvironment[] {
    return environments.map(
      (environment) => new StorageIntgrationTestEnvironment(this, environment)
    );
  }
}

class StorageIntgrationTestEnvironment extends IntegrationTestStackEnvironment<StorageIntegrationTestEnvironmentProps> {
  constructor(scope: Construct, props: StorageIntegrationTestEnvironmentProps) {
    super(scope, props);

    // Create the bucket

    const bucket = new s3.Bucket(this, "Bucket", {
      removalPolicy: RemovalPolicy.DESTROY,
      autoDeleteObjects: true,
      enforceSSL: true,
      cors: [
        // Matches configuration generated by Amplify CLI
        {
          allowedMethods: [
            s3.HttpMethods.GET,
            s3.HttpMethods.PUT,
            s3.HttpMethods.HEAD,
            s3.HttpMethods.POST,
            s3.HttpMethods.DELETE,
          ],
          allowedHeaders: ["*"],
          allowedOrigins: ["*"],
          exposedHeaders: [
            "x-amz-server-side-encryption",
            "x-amz-request-id",
            "x-amz-id-2",
            "ETag",
          ],
          maxAge: 3000,
        },
      ],
    });

    // Create the Cognito User Pool

    // Pre sign-up trigger to auto-confirm users.
    const autoConfirmTrigger = new lambda_nodejs.NodejsFunction(
      this,
      "auto-confirm",
      {
        runtime: lambda.Runtime.NODEJS_16_X,
      }
    );

    const userPool = new cognito.UserPool(this, "UserPool", {
      userPoolName: this.environmentName,
      removalPolicy: RemovalPolicy.DESTROY,
      selfSignUpEnabled: true,
      accountRecovery: cognito.AccountRecovery.NONE,
      mfa: cognito.Mfa.OFF,
      lambdaTriggers: {
        preSignUp: autoConfirmTrigger,
      },
    });

    const userPoolClient = userPool.addClient("UserPoolClient", {
      authFlows: {
        userSrp: true,
      },
      disableOAuth: true,
    });

    // Create the Cognito Identity Pool

    const identityPool = new cognito.CfnIdentityPool(this, "IdentityPool", {
      identityPoolName: this.environmentName,
      allowUnauthenticatedIdentities: true,
      cognitoIdentityProviders: [
        {
          clientId: userPoolClient.userPoolClientId,
          providerName: `cognito-idp.${this.region}.amazonaws.com/${userPool.userPoolId}`,
        },
      ],
    });

    const identityId = "${cognito-identity.amazonaws.com:sub}";
    const prefixes: Record<StorageAccessLevel, string> = {
      [StorageAccessLevel.public]: props.prefixResolver
        ? props.prefixResolver(StorageAccessLevel.public, identityId)
        : "public/",
      [StorageAccessLevel.protected]: props.prefixResolver
        ? props.prefixResolver(StorageAccessLevel.protected, identityId)
        : `protected/${identityId}/`,
      [StorageAccessLevel.private]: props.prefixResolver
        ? props.prefixResolver(StorageAccessLevel.private, identityId)
        : `private/${identityId}/`,
    };
    const prefixOverrides = props.prefixOverrides;
    const buildPolicyDocument = (accessLevel: StorageAccessLevel) => {
      let permissions = [
        StoragePermission.get,
        StoragePermission.put,
        StoragePermission.delete,
      ];
      if (props.accessLevels) {
        permissions = props.accessLevels[accessLevel];
      }
      const prefix = prefixes[accessLevel];
      return new iam.PolicyDocument({
        statements: [
          new iam.PolicyStatement({
            actions: permissions,
            resources: [`${bucket.bucketArn}/${prefix}*`],
          }),
        ],
      });
    };

    const unauthenticatedPolicies: Record<string, iam.PolicyDocument> = {
      "read-unauth": new iam.PolicyDocument({
        statements: [
          new iam.PolicyStatement({
            actions: ["s3:ListBucket"],
            conditions: {
              StringLike: {
                "s3:prefix": Array.from(
                  new Set(
                    [
                      `${prefixes[StorageAccessLevel.public]}`,
                      `${prefixes[StorageAccessLevel.public]}*`,
                      `${prefixes[StorageAccessLevel.protected]}`,
                      `${prefixes[StorageAccessLevel.protected]}*`,
                      `${
                        prefixOverrides?.[StorageAccessLevel.protected] ??
                        "protected"
                      }/`,
                      `${
                        prefixOverrides?.[StorageAccessLevel.protected] ??
                        "protected"
                      }/*`,
                    ].filter((val) => val !== "")
                  )
                ),
              },
            },
            resources: [bucket.bucketArn],
          }),
        ],
      }),
      public: buildPolicyDocument(StorageAccessLevel.public),
      protected: buildPolicyDocument(StorageAccessLevel.protected),
    };
    const unauthenticatedRole = new iam.Role(this, "UnauthenticatedRole", {
      description: "Default role for anonymous users",
      assumedBy: new iam.FederatedPrincipal(
        "cognito-identity.amazonaws.com",
        {
          StringEquals: {
            "cognito-identity.amazonaws.com:aud": identityPool.ref,
          },
          "ForAnyValue:StringLike": {
            "cognito-identity.amazonaws.com:amr": "unauthenticated",
          },
        },
        "sts:AssumeRoleWithWebIdentity"
      ),
      inlinePolicies: unauthenticatedPolicies,
    });

    const authenticatedPolicies: Record<string, iam.PolicyDocument> = {
      ...unauthenticatedPolicies,
      "read-auth": new iam.PolicyDocument({
        statements: [
          new iam.PolicyStatement({
            actions: ["s3:GetObject"],
            resources: [
              `${bucket.bucketArn}/${
                prefixOverrides?.[StorageAccessLevel.protected] ?? "protected"
              }/*`,
            ],
          }),
          new iam.PolicyStatement({
            actions: ["s3:ListBucket"],
            conditions: {
              StringLike: {
                "s3:prefix": [
                  `${prefixes[StorageAccessLevel.private]}`,
                  `${prefixes[StorageAccessLevel.private]}*`,
                ],
              },
            },
            resources: [bucket.bucketArn],
          }),
        ],
      }),
      private: buildPolicyDocument(StorageAccessLevel.private),
    };
    const authenticatedRole = new iam.Role(this, "AuthenticatedRole", {
      description: "Default role for authenticated users",
      assumedBy: new iam.FederatedPrincipal(
        "cognito-identity.amazonaws.com",
        {
          StringEquals: {
            "cognito-identity.amazonaws.com:aud": identityPool.ref,
          },
          "ForAnyValue:StringLike": {
            "cognito-identity.amazonaws.com:amr": "authenticated",
          },
        },
        "sts:AssumeRoleWithWebIdentity"
      ),
      inlinePolicies: authenticatedPolicies,
    });

    new cognito.CfnIdentityPoolRoleAttachment(
      this,
      "IdentityPoolRoleAttachment",
      {
        identityPoolId: identityPool.ref,
        roles: {
          unauthenticated: unauthenticatedRole.roleArn,
          authenticated: authenticatedRole.roleArn,
        },
      }
    );

    // Save the values needed to build our Amplify configuration.

    this.config = {
      authConfig: {
        userPoolConfig: {
          userPoolId: userPool.userPoolId,
          userPoolClientId: userPoolClient.userPoolClientId,
        },
        identityPoolConfig: {
          identityPoolId: identityPool.ref,
        },
      },
      storageConfig: {
        bucket: bucket.bucketName,
        defaultAccessLevel:
          props.defaultAccessLevel || StorageAccessLevel.public,
      },
    };
  }
}
